---
alwaysApply: true
---
Essential Hooks Guidelines for Kuavo Data Challenge

1. Executive Summary

This document defines the "essential hooks" for the Kuavo Data Challenge project. These hooks represent the critical interfaces between:

ROS and Data Processing: How raw messages become training samples.

User Configuration and Training: How Hydra configs drive the LeRobot training loop.

Policy and Robot Hardware: How neural network outputs become physical joint commands.

Adherence to these hooks is mandatory to ensure safety (on the real robot) and reproducibility (in training).

2. Definition of "Essential Hooks" in This Project

In the context of this software, "Essential Hooks" are defined as:

ROS Callbacks: The specific methods in ros_handler.py and KuavoMsgProcesser that ingest high-frequency sensor data.

Gymnasium Interface Methods: The reset() and step() methods in KuavoBaseRosEnv that serve as the bridge between the policy and the hardware.

LeRobot Extension Points: The specific methods in lerobot_patches and wrapper/ that inject custom logic into the standard framework.

Safety Interceptors: The code blocks that must execute before any command is sent to the physical robot.

3. Categories of Essential Hooks and Implementation Guidelines

3.1. Data Ingestion Hooks (ROS -> Parquet)

These hooks manage the extraction of synchronized data from unsynchronized ROS streams.

ROS Message Hook: ROSHandler._generic_callback(msg, topic_name)

Description: The entry point for every ROS message in the multiprocessing handler.

Contract: Must extract the timestamp immediately upon receipt. Must put data into the multiprocessing.Queue without blocking.

Processing Hook: KuavoMsgProcesser.process_*_image(msg) & process_*_state(msg)

Description: Static methods responsible for converting ROS types (e.g., sensor_msgs/Image) to Python types (e.g., numpy.ndarray).

Contract: Must handle cv_bridge exceptions. Must normalize timestamps to seconds (float).

Alignment Hook: KuavoRosbagReader.align_frame_data(data)

Description: The logic that decides which messages belong to the same "frame".

Contract: Must use searchsorted or similar efficient algorithms to match timestamps within a tolerance (default 30ms). Drops frames that cannot be aligned.

3.2. Training Hooks (LeRobot Integration)

These hooks inject custom Kuavo-specific logic into the generic LeRobot training loop.

Dataset Wrapper Hook: LeRobotDatasetWrapper.__getitem__(idx)

Description: The point where raw data is served to the DataLoader.

Contract: Must return a dictionary where keys exactly match the policy's expected input features (e.g., observation.images.cam_high, observation.state). Must apply RGB_Augmenter here.

Policy Forward Hook: CustomDiffusionPolicyWrapper.forward(batch)

Description: The training step execution.

Contract: Must accept a batch containing both RGB and Depth (if configured). Must normalize inputs using the statistics computed during data processing.

Patch Hook: lerobot_patches.custom_patches (Import Time)

Description: Must be imported before lerobot.common.datasets.

Contract: Monkey-patches FeatureType to include DEPTH and registers custom statistics computation functions.

3.3. Deployment Hooks (Policy -> Robot)

These are the most critical hooks, governing the real-time control loop.

Gym Reset Hook: KuavoBaseRosEnv.reset(seed=None, options=None)

Description: Called at the start of every evaluation episode.

Contract:

Move robot to arm_init configuration (home position).

Clear all ROS message buffers to prevent stale observations.

Wait for fresh messages from all required topics.

Return the initial observation.

Gym Step Hook: KuavoBaseRosEnv.step(action)

Description: The core control loop iteration.

Contract:

Safety Check: Call check_action(action) to ensure limits.

Execute: Publish joint commands to ROS.

Wait: Sleep to maintain ros_rate (e.g., 30Hz).

Observe: Capture the next state from ROS topics.

Safety Interceptor Hook: KuavoBaseRosEnv.check_action(action)

Description: The final gatekeeper before hardware execution.

Contract:

Clamp action values to [arm_min, arm_max].

Check for NaN or Inf values.

If safety violation is detected, log error and return a safe "hold" action or raise an exception.

3.4. Human Intervention Hooks

These hooks allow human operators to override or stop the robot.

Key Press Hook: KeyListener.on_press(key)

Description: Listens for keyboard input in a separate thread.

Contract:

Esc: Set stop_flag.

Enter: Set pause_flag.

Control Loop Check Hook: eval_kuavo.check_control_signals()

Description: Called inside the main evaluation loop before env.step().

Contract:

If stop_flag is set -> Break loop, safe park robot.

If pause_flag is set -> Enter spin loop, publishing current state as command (hold position).

3.5. Configuration Hooks

Hydra Entry Hook: @hydra.main(config_path=..., config_name=...)

Description: All main scripts (train, eval, convert) must use this decorator.

Contract: The cfg object passed to main() is immutable and serves as the single source of truth.

4. Error Handling Hooks

ROS Connection Hook:

Description: On startup, KuavoBaseRosEnv checks for the existence of required topics.

Action: If topics are missing (e.g., camera not plugged in), raise RuntimeError immediately. Do not start the policy.

Inference Exception Hook:

Description: Wrapped around the policy inference call.

Action: If the model fails (e.g., CUDA OOM), the finally block must execute a safe stop command to the robot.