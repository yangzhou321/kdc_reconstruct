# æ•°æ®è¯»å–ä¸å¸§å¯¹é½æœºåˆ¶è¯´æ˜

## ğŸ“‹ æ¦‚è¿°

æœ¬é¡¹ç›®**ä¸ä½¿ç”¨ ROS bag**ï¼Œè€Œæ˜¯ä½¿ç”¨ **Zarr æ ¼å¼**å­˜å‚¨æ•°æ®ã€‚æ•°æ®è¯»å–é‡‡ç”¨**æŒ‰éœ€è¯»å–ï¼ˆLazy Loadingï¼‰**æ–¹å¼ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡æ€§åŠ è½½æ•´ä¸ªæ•°æ®é›†åˆ°å†…å­˜ã€‚å¸§å¯¹é½åœ¨**å½•åˆ¶æ—¶**å®Œæˆï¼Œè®­ç»ƒæ—¶æ•°æ®å·²ç»å¯¹é½ã€‚

## ğŸ—‚ï¸ æ•°æ®å­˜å‚¨æ ¼å¼

### å­˜å‚¨æ ¼å¼ï¼šZarrï¼ˆä¸æ˜¯ ROS bagï¼‰

é¡¹ç›®ä½¿ç”¨ **Zarr** ä½œä¸ºä¸»è¦æ•°æ®å­˜å‚¨æ ¼å¼ï¼ŒåŸå› ï¼š
- æ”¯æŒåˆ†å—å­˜å‚¨ï¼ˆchunked storageï¼‰
- æ”¯æŒå¹¶è¡Œè¯»å†™
- æ”¯æŒå†…å­˜æ˜ å°„ï¼ˆmemory-mapped accessï¼‰
- æ”¯æŒå‹ç¼©ï¼ˆJPEG2000 ç­‰ï¼‰
- é€‚åˆå¤§è§„æ¨¡æ•°æ®é›†

### æ•°æ®ç»“æ„

```
data/pusht_cchi_v7_replay.zarr
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ action (25650, 2) float32
â”‚   â”œâ”€â”€ img (25650, 96, 96, 3) float32
â”‚   â”œâ”€â”€ keypoint (25650, 9, 2) float32
â”‚   â””â”€â”€ state (25650, 5) float32
â””â”€â”€ meta/
    â””â”€â”€ episode_ends (206,) int64
```

**ç‰¹ç‚¹**ï¼š
- æ‰€æœ‰ episode çš„æ•°æ®åœ¨æ—¶é—´ç»´åº¦ä¸Š**æ‹¼æ¥**ï¼ˆconcatenatedï¼‰
- `episode_ends` è®°å½•æ¯ä¸ª episode çš„ç»“æŸç´¢å¼•
- æ¯ä¸ªæ•°ç»„æŒ‰æ—¶é—´æ­¥ï¼ˆç¬¬ä¸€ç»´ï¼‰ç»„ç»‡

## ğŸ”„ æ•°æ®è¯»å–æ–¹å¼

### æ–¹å¼ï¼šæŒ‰éœ€è¯»å–ï¼ˆLazy Loadingï¼‰ï¼Œä¸æ˜¯ä¸€æ¬¡æ€§åŠ è½½

#### 1. è®­ç»ƒæ—¶çš„æ•°æ®è¯»å–æµç¨‹

**ä»£ç ä½ç½®**ï¼š`diffusion_policy/dataset/*_dataset.py`

```python
# ç¤ºä¾‹ï¼šreal_pusht_image_dataset.py
class RealPushTImageDataset(BaseImageDataset):
    def __init__(self, ...):
        # åªåŠ è½½ ReplayBuffer çš„å…ƒæ•°æ®ï¼Œä¸åŠ è½½å®é™…æ•°æ®
        replay_buffer = ReplayBuffer.create_from_path(
            zarr_path=zarr_path, mode='r')  # åªè¯»æ¨¡å¼
        
        # åˆ›å»ºé‡‡æ ·å™¨ï¼Œé¢„è®¡ç®—ç´¢å¼•
        sampler = SequenceSampler(
            replay_buffer=replay_buffer,
            sequence_length=horizon,
            ...
        )
    
    def __getitem__(self, idx: int):
        # æŒ‰éœ€è¯»å–ï¼šåªè¯»å–å½“å‰æ ·æœ¬éœ€è¦çš„æ•°æ®
        data = self.sampler.sample_sequence(idx)
        # è¿”å› PyTorch tensor
        return torch_data
```

**å…³é”®ç‚¹**ï¼š
- `ReplayBuffer.create_from_path()` åªæ‰“å¼€æ–‡ä»¶ï¼Œä¸åŠ è½½æ•°æ®
- `SequenceSampler` é¢„è®¡ç®—æ‰€æœ‰æ ·æœ¬çš„ç´¢å¼•
- `__getitem__()` è¢«è°ƒç”¨æ—¶æ‰è¯»å–å¯¹åº”çš„æ•°æ®å—

#### 2. SequenceSampler çš„å·¥ä½œåŸç†

**ä»£ç ä½ç½®**ï¼š`diffusion_policy/common/sampler.py`

```121:153:diffusion_policy/common/sampler.py
    def sample_sequence(self, idx):
        buffer_start_idx, buffer_end_idx, sample_start_idx, sample_end_idx \
            = self.indices[idx]
        result = dict()
        for key in self.keys:
            input_arr = self.replay_buffer[key]
            # performance optimization, avoid small allocation if possible
            if key not in self.key_first_k:
                sample = input_arr[buffer_start_idx:buffer_end_idx]
            else:
                # performance optimization, only load used obs steps
                n_data = buffer_end_idx - buffer_start_idx
                k_data = min(self.key_first_k[key], n_data)
                # fill value with Nan to catch bugs
                # the non-loaded region should never be used
                sample = np.full((n_data,) + input_arr.shape[1:], 
                    fill_value=np.nan, dtype=input_arr.dtype)
                try:
                    sample[:k_data] = input_arr[buffer_start_idx:buffer_start_idx+k_data]
                except Exception as e:
                    import pdb; pdb.set_trace()
            data = sample
            if (sample_start_idx > 0) or (sample_end_idx < self.sequence_length):
                data = np.zeros(
                    shape=(self.sequence_length,) + input_arr.shape[1:],
                    dtype=input_arr.dtype)
                if sample_start_idx > 0:
                    data[:sample_start_idx] = sample[0]
                if sample_end_idx < self.sequence_length:
                    data[sample_end_idx:] = sample[-1]
                data[sample_start_idx:sample_end_idx] = sample
            result[key] = data
        return result
```

**ä¼˜åŒ–ç­–ç•¥**ï¼š
1. **æŒ‰éœ€è¯»å–**ï¼š`input_arr[buffer_start_idx:buffer_end_idx]` åªè¯»å–éœ€è¦çš„åˆ‡ç‰‡
2. **éƒ¨åˆ†åŠ è½½**ï¼šä½¿ç”¨ `key_first_k` åªåŠ è½½å‰ k ä¸ªè§‚å¯Ÿæ­¥ï¼ˆèŠ‚çœå†…å­˜ï¼‰
3. **Zarr åˆ†å—**ï¼šZarr è‡ªåŠ¨å¤„ç†åˆ†å—è¯»å–ï¼ŒåªåŠ è½½ç›¸å…³çš„ chunk

#### 3. ä¸ ROS bag çš„å¯¹æ¯”

| ç‰¹æ€§ | ROS bagï¼ˆä¸€æ¬¡æ€§åŠ è½½ï¼‰ | æœ¬é¡¹ç›®ï¼ˆæŒ‰éœ€è¯»å–ï¼‰ |
|------|---------------------|------------------|
| æ•°æ®æ ¼å¼ | ROS bag | Zarr |
| åŠ è½½æ–¹å¼ | å…¨éƒ¨è¯»å…¥ dict | æŒ‰éœ€è¯»å–åˆ‡ç‰‡ |
| å†…å­˜å ç”¨ | é«˜ï¼ˆæ•´ä¸ªæ•°æ®é›†ï¼‰ | ä½ï¼ˆåªåŠ è½½å½“å‰ batchï¼‰ |
| è¯»å–æ•ˆç‡ | ä½ï¼ˆéœ€è¦å…¨éƒ¨è§£æï¼‰ | é«˜ï¼ˆåªè¯»å–éœ€è¦çš„ chunkï¼‰ |
| å¸§å¯¹é½ | è¯»å–åå¯¹é½ | å½•åˆ¶æ—¶å·²å¯¹é½ |

## ğŸ¯ å¸§å¯¹é½æ–¹å¼

### å¯¹é½æ—¶æœºï¼šå½•åˆ¶æ—¶å¯¹é½ï¼Œè®­ç»ƒæ—¶ç›´æ¥ä½¿ç”¨

#### 1. å½•åˆ¶æ—¶çš„å¸§å¯¹é½ï¼ˆå®æ—¶å¯¹é½ï¼‰

**ä»£ç ä½ç½®**ï¼š`diffusion_policy/real_world/real_env.py` å’Œ `timestamp_accumulator.py`

**æµç¨‹**ï¼š

```python
# åœ¨ RealEnv.start_episode() ä¸­
self.obs_accumulator = TimestampObsAccumulator(
    start_time=start_time,
    dt=1/self.frequency  # 10 Hz
)

# åœ¨ get_obs() ä¸­å®æ—¶å¯¹é½
obs_align_timestamps = last_timestamp - (np.arange(n_obs_steps)[::-1] * dt)
# å¯¹é½ç›¸æœºå’Œæœºå™¨äººæ•°æ®åˆ°ç»Ÿä¸€æ—¶é—´æˆ³
```

**å¯¹é½è¿‡ç¨‹**ï¼š
1. **å®æ—¶æ•°æ®é‡‡é›†**ï¼š
   - ç›¸æœºï¼š30 Hzï¼ˆ`camera_receive_timestamp`ï¼‰
   - æœºå™¨äººï¼š125 Hzï¼ˆ`robot_receive_timestamp`ï¼‰

2. **æ—¶é—´æˆ³å¯¹é½**ï¼š
   ```python
   # ç”Ÿæˆç›®æ ‡æ—¶é—´æˆ³ï¼ˆ10 Hz ç½‘æ ¼ï¼‰
   obs_align_timestamps = [t-0.1, t]  # n_obs_steps=2
   
   # ä¸ºæ¯ä¸ªç›®æ ‡æ—¶é—´æˆ³æ‰¾åˆ°æœ€è¿‘çš„æ•°æ®å¸§
   for t in obs_align_timestamps:
       is_before_idxs = np.nonzero(this_timestamps < t)[0]
       this_idx = is_before_idxs[-1]  # æœ€è¿‘é‚»
   ```

3. **æ•°æ®ç´¯ç§¯**ï¼š
   ```python
   # ä½¿ç”¨ TimestampObsAccumulator ç´¯ç§¯å¯¹é½åçš„æ•°æ®
   self.obs_accumulator.put(robot_obs_raw, robot_timestamps)
   ```

4. **ä¿å­˜åˆ° Zarr**ï¼š
   - å¯¹é½åçš„æ•°æ®ç›´æ¥ä¿å­˜åˆ° ReplayBuffer
   - æ•°æ®å·²ç»æŒ‰ç»Ÿä¸€æ—¶é—´ç½‘æ ¼ç»„ç»‡

#### 2. è®­ç»ƒæ—¶çš„æ•°æ®ä½¿ç”¨ï¼ˆæ— éœ€å¯¹é½ï¼‰

**è®­ç»ƒæ—¶æ•°æ®å·²ç»å¯¹é½**ï¼š
- å½•åˆ¶æ—¶å·²ç»å¯¹é½åˆ°ç»Ÿä¸€æ—¶é—´ç½‘æ ¼ï¼ˆ10 Hzï¼‰
- æ‰€æœ‰æ•°æ®æºï¼ˆç›¸æœºã€æœºå™¨äººï¼‰éƒ½å·²å¯¹é½
- è®­ç»ƒæ—¶ç›´æ¥æŒ‰ç´¢å¼•è¯»å–å³å¯

```python
# è®­ç»ƒæ—¶ï¼šç›´æ¥è¯»å–å·²å¯¹é½çš„æ•°æ®
def __getitem__(self, idx):
    # è¯»å–åºåˆ—ï¼Œæ•°æ®å·²ç»å¯¹é½
    sample = self.sampler.sample_sequence(idx)
    # sample['camera_0'] å’Œ sample['robot_eef_pose'] å·²ç»å¯¹é½
    return sample
```

## ğŸ“Š æ•°æ®è¯»å–æµç¨‹è¯¦è§£

### åœºæ™¯ 1ï¼šä»çœŸå®æœºå™¨äººæ•°æ®è½¬æ¢

**ä»£ç ä½ç½®**ï¼š`diffusion_policy/real_world/real_data_conversion.py`

```python
def real_data_to_replay_buffer(dataset_path, ...):
    # 1. è¯»å–åŸå§‹ Zarrï¼ˆåŒ…å«æ—¶é—´æˆ³å¯¹é½çš„æ•°æ®ï¼‰
    in_replay_buffer = ReplayBuffer.create_from_path(...)
    
    # 2. æµå¼è¯»å–è§†é¢‘æ–‡ä»¶ï¼ˆä¸æ˜¯ä¸€æ¬¡æ€§åŠ è½½ï¼‰
    for step_idx, frame in enumerate(read_video(...)):
        # 3. ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œå¤„ç†
        futures.add(executor.submit(put_img, arr, global_idx, frame))
    
    # 4. ä¿å­˜åˆ°æ–°çš„ Zarrï¼ˆå‹ç¼©æ ¼å¼ï¼‰
    return out_replay_buffer
```

**å…³é”®ç‚¹**ï¼š
- **æµå¼è¯»å–**ï¼š`read_video()` æ˜¯ç”Ÿæˆå™¨ï¼Œé€å¸§è¯»å–
- **å¹¶è¡Œå¤„ç†**ï¼šä½¿ç”¨ `ThreadPoolExecutor` å¹¶è¡Œç¼–ç å›¾åƒ
- **æŒ‰éœ€å†™å…¥**ï¼šåªå¤„ç†éœ€è¦çš„å¸§ï¼Œä¸å…¨éƒ¨åŠ è½½

### åœºæ™¯ 2ï¼šè®­ç»ƒæ—¶çš„æ•°æ®é‡‡æ ·

**ä»£ç ä½ç½®**ï¼š`diffusion_policy/dataset/real_pusht_image_dataset.py`

```183:218:diffusion_policy/dataset/real_pusht_image_dataset.py
    def __getitem__(self, idx: int) -> Dict[str, torch.Tensor]:
        threadpool_limits(1)
        data = self.sampler.sample_sequence(idx)

        # to save RAM, only return first n_obs_steps of OBS
        # since the rest will be discarded anyway.
        # when self.n_obs_steps is None
        # this slice does nothing (takes all)
        T_slice = slice(self.n_obs_steps)

        obs_dict = dict()
        for key in self.rgb_keys:
            # move channel last to channel first
            # T,H,W,C
            # convert uint8 image to float32
            obs_dict[key] = np.moveaxis(data[key][T_slice],-1,1
                ).astype(np.float32) / 255.
            # T,C,H,W
            # save ram
            del data[key]
        for key in self.lowdim_keys:
            obs_dict[key] = data[key][T_slice].astype(np.float32)
            # save ram
            del data[key]
        
        action = data['action'].astype(np.float32)
        # handle latency by dropping first n_latency_steps action
        # observations are already taken care of by T_slice
        if self.n_latency_steps > 0:
            action = action[self.n_latency_steps:]

        torch_data = {
            'obs': dict_apply(obs_dict, torch.from_numpy),
            'action': torch.from_numpy(action)
        }
        return torch_data
```

**ä¼˜åŒ–ç­–ç•¥**ï¼š
1. **éƒ¨åˆ†åŠ è½½**ï¼š`T_slice = slice(n_obs_steps)` åªåŠ è½½å‰ n ä¸ªè§‚å¯Ÿæ­¥
2. **åŠæ—¶é‡Šæ”¾**ï¼š`del data[key]` ç«‹å³é‡Šæ”¾ä¸éœ€è¦çš„æ•°æ®
3. **æŒ‰éœ€è½¬æ¢**ï¼šåªåœ¨éœ€è¦æ—¶è½¬æ¢ä¸º PyTorch tensor

## ğŸ” ä¸ ROS bag æ–¹å¼çš„å¯¹æ¯”

### ROS bag æ–¹å¼ï¼ˆä¸€æ¬¡æ€§åŠ è½½ï¼‰

```python
# ä¸å¥½çš„æ–¹å¼ï¼šä¸€æ¬¡æ€§åŠ è½½æ•´ä¸ª bag
bag = rosbag.Bag('data.bag')
all_messages = {}
for topic, msg, t in bag.read_messages():
    if topic not in all_messages:
        all_messages[topic] = []
    all_messages[topic].append(msg)

# ç„¶åå¯¹é½
aligned_data = align_frames(all_messages)  # å†…å­˜å ç”¨é«˜
```

**é—®é¢˜**ï¼š
- å†…å­˜å ç”¨é«˜ï¼ˆæ•´ä¸ªæ•°æ®é›†åœ¨å†…å­˜ä¸­ï¼‰
- è¯»å–æ…¢ï¼ˆéœ€è¦è§£ææ•´ä¸ª bagï¼‰
- å¯¹é½æ•ˆç‡ä½ï¼ˆéœ€è¦å¤„ç†å¤§é‡æ•°æ®ï¼‰

### æœ¬é¡¹ç›®æ–¹å¼ï¼ˆæŒ‰éœ€è¯»å– + å½•åˆ¶æ—¶å¯¹é½ï¼‰

```python
# å½•åˆ¶æ—¶ï¼šå®æ—¶å¯¹é½å¹¶ä¿å­˜
obs_accumulator.put(obs_data, timestamps)  # å¯¹é½åä¿å­˜

# è®­ç»ƒæ—¶ï¼šæŒ‰éœ€è¯»å–
def __getitem__(self, idx):
    # åªè¯»å–éœ€è¦çš„åˆ‡ç‰‡
    sample = self.replay_buffer[start:end]  # Zarr è‡ªåŠ¨åˆ†å—è¯»å–
    return sample
```

**ä¼˜åŠ¿**ï¼š
- å†…å­˜å ç”¨ä½ï¼ˆåªåŠ è½½å½“å‰ batchï¼‰
- è¯»å–å¿«ï¼ˆZarr åˆ†å—è¯»å–ï¼‰
- å¯¹é½é«˜æ•ˆï¼ˆå½•åˆ¶æ—¶å·²å®Œæˆï¼‰

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. Zarr åˆ†å—å­˜å‚¨

```python
# å›¾åƒæ•°æ®ä½¿ç”¨åˆ†å—å­˜å‚¨
chunks=(1, height, width, 3)  # æ¯å¸§ä¸€ä¸ª chunk
compressor=Jpeg2k(level=50)   # JPEG2000 å‹ç¼©
```

**æ•ˆæœ**ï¼š
- åªè¯»å–éœ€è¦çš„ chunk
- å¹¶è¡Œè¯»å–å¤šä¸ª chunk
- å‹ç¼©å‡å°‘ I/O

### 2. éƒ¨åˆ†æ•°æ®åŠ è½½

```python
# åªåŠ è½½å‰ n_obs_steps ä¸ªè§‚å¯Ÿæ­¥
key_first_k = {'camera_0': n_obs_steps}
sample[:k_data] = input_arr[buffer_start_idx:buffer_start_idx+k_data]
```

**æ•ˆæœ**ï¼š
- å‡å°‘å†…å­˜å ç”¨
- åŠ å¿«è¯»å–é€Ÿåº¦
- é€‚åˆåºåˆ—æ¨¡å‹ï¼ˆåªéœ€è¦å‰å‡ æ­¥ï¼‰

### 3. å†…å­˜æ˜ å°„ï¼ˆMemory Mappingï¼‰

```python
# Zarr æ”¯æŒå†…å­˜æ˜ å°„
replay_buffer = ReplayBuffer.create_from_path(zarr_path, mode='r')
# æ•°æ®ä¸ç«‹å³åŠ è½½ï¼ŒæŒ‰éœ€ä»ç£ç›˜è¯»å–
```

**æ•ˆæœ**ï¼š
- å»¶è¿ŸåŠ è½½
- æ“ä½œç³»ç»Ÿè‡ªåŠ¨ç®¡ç†ç¼“å­˜
- é€‚åˆå¤§æ•°æ®é›†

## ğŸ¯ æ€»ç»“

### æ•°æ®è¯»å–ç­–ç•¥

1. **å­˜å‚¨æ ¼å¼**ï¼šZarrï¼ˆä¸æ˜¯ ROS bagï¼‰
2. **è¯»å–æ–¹å¼**ï¼šæŒ‰éœ€è¯»å–ï¼ˆLazy Loadingï¼‰
3. **å¯¹é½æ—¶æœº**ï¼šå½•åˆ¶æ—¶å¯¹é½ï¼Œè®­ç»ƒæ—¶ç›´æ¥ä½¿ç”¨
4. **ä¼˜åŒ–æŠ€æœ¯**ï¼šåˆ†å—å­˜å‚¨ã€éƒ¨åˆ†åŠ è½½ã€å†…å­˜æ˜ å°„

### å…³é”®ä»£ç æ–‡ä»¶

- **æ•°æ®è¯»å–**ï¼š`diffusion_policy/dataset/*_dataset.py`
- **é‡‡æ ·å™¨**ï¼š`diffusion_policy/common/sampler.py`
- **å­˜å‚¨æ ¼å¼**ï¼š`diffusion_policy/common/replay_buffer.py`
- **å¸§å¯¹é½**ï¼š`diffusion_policy/common/timestamp_accumulator.py`
- **æ•°æ®è½¬æ¢**ï¼š`diffusion_policy/real_world/real_data_conversion.py`

### ä¸ ROS bag çš„å¯¹æ¯”

| ç‰¹æ€§ | ROS bagï¼ˆä¸€æ¬¡æ€§åŠ è½½ï¼‰ | æœ¬é¡¹ç›®ï¼ˆæŒ‰éœ€è¯»å–ï¼‰ |
|------|---------------------|------------------|
| **æ•ˆç‡** | â­â­ | â­â­â­â­â­ |
| **å†…å­˜å ç”¨** | â­â­ | â­â­â­â­â­ |
| **å¯¹é½æ–¹å¼** | è¯»å–åå¯¹é½ | å½•åˆ¶æ—¶å¯¹é½ |
| **é€‚ç”¨åœºæ™¯** | å°æ•°æ®é›† | å¤§æ•°æ®é›† |

**ç»“è®º**ï¼šæœ¬é¡¹ç›®é‡‡ç”¨**é«˜æ•ˆçš„æŒ‰éœ€è¯»å– + å½•åˆ¶æ—¶å¯¹é½**ç­–ç•¥ï¼Œé¿å…äº† ROS bag ä¸€æ¬¡æ€§åŠ è½½çš„é—®é¢˜ã€‚


